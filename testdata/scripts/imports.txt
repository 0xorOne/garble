garble build
exec ./main
cmp stdout main.stdout

! binsubstr main$exe 'ImportedVar' 'ImportedConst' 'ImportedFunc' 'ImportedType' 'main.go' 'imported.go'

[short] stop # checking that the build is reproducible is slow

# Also check that the binary is reproducible when many imports are involved.
cp main$exe main_old$exe
rm main$exe
garble build
bincmp main$exe main_old$exe

go build
exec ./main
cmp stdout main.stdout

-- go.mod --
module test/main
-- main.go --
package main

import (
	"fmt"
	_ "unsafe"

	"test/main/imported"

	"rsc.io/quote"
)

//go:linkname linkedPrintln fmt.Println
func linkedPrintln(a ...interface{}) (n int, err error)

func main() {
	fmt.Println(imported.ImportedVar)
	fmt.Println(imported.ImportedConst)
	imported.ImportedFunc('x')
	fmt.Println(imported.ImportedType(3))

	fmt.Printf("%T\n", imported.ReflectTypeOf(2))
	fmt.Printf("%T\n", imported.ReflectTypeOfIndirect(4))
	fmt.Printf("%#v\n", imported.ReflectValueOfVar)

	linkedPrintln(nil)
	fmt.Println(quote.Go())
}
-- imported/imported.go --
package imported

import "reflect"

var ImportedVar = "imported var value"

const ImportedConst = "imported const value"

func ImportedFunc(param rune) string {
	return string(param)
}

type ReflectTypeOf int

var _ = reflect.TypeOf(ReflectTypeOf(0))

type ReflectTypeOfIndirect int

var _ = reflect.TypeOf(new([]*ReflectTypeOfIndirect))

type ReflectValueOf struct {
	Foo int `bar:"baz"`
}

var ReflectValueOfVar = ReflectValueOf{Foo: 3}

var _ = reflect.TypeOf(ReflectValueOfVar)

// ImportedType comes after the calls to reflect, to ensure no false positives.
type ImportedType int

-- main.stdout --
imported var value
imported const value
3
imported.ReflectTypeOf
imported.ReflectTypeOfIndirect
imported.ReflectValueOf{Foo:3}
<nil>
Don't communicate by sharing memory, share memory by communicating.

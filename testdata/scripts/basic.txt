[!exec:go] skip
[!symlink] skip

# We want to use the current garble, not whichever happens to be globally
# installed. Use the test binary with TESTSCRIPT_COMMAND, which we know will
# correctly run garble thanks to go-internal/testscript.
mkdir .bin
symlink .bin/garble$exe -> $TESTBIN
env PATH=$WORK/.bin${:}$PATH
env TESTSCRIPT_COMMAND=garble

# Check that the program works as expected without garble.
exec go build main.go
exec ./main
cmp stderr main.stderr
grep $WORK main

# The default build includes DWARF and the symbol table.
exec readelf --section-details --symbols main
stdout 'debug_info$'
stdout 'globalVar'

# The default build includes full non-trimmed paths.
grep $WORK main

# Check that we fail if the user forgot -trimpath.
! exec go build -a -toolexec=garble main.go
stderr 'should be used alongside -trimpath'

# Check that the simplest use of garble works.
exec go build -a -trimpath -toolexec=garble main.go
exec ./main
cmp stderr main.stderr

exec readelf --section-details --symbols main
! stdout 'debug_info$'
! stdout 'globalVar'

! grep $WORK main

# TODO
# ! grep 'globalVar' main
# ! grep 'globalFunc' main

-- main.go --
package main

var globalVar = "global value"

func globalFunc() { println("global func body") }

func main() {
	println(globalVar)
	globalFunc()
}
-- main.stderr --
global value
global func body
